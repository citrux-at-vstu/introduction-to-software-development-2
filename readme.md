# Лабораторная работа № 2

*Разработка через тестирование (TDD)* 

*Изучение модульных тестов, оболочки NUnit, шаблонов тестирования и рефакторинга*

## 1. Цели работы

1. Научиться создавать простые модульные тесты.
2.	Познакомиться с оболочкой NUnit.
3.	Познакомиться с принципами разработки через тестирование (TDD) и простыми шаблонами тестирования. 
4.	Разработать проект реализации и подробный план первой итерации для своей курсовой работы (до уровня создаваемых тестов).
5.	Реализовать необходимые тесты и модули для первой итерации своей курсовой работы.

## 2. Некоторые теоретические сведения и понятия
	
В данной работе на практике изучается модульное тестирование, разработка через тестирование (TDD), а также семейство оболочек тестирования xUnit на примере оболочки NUnit для .NET - проектов.   

Модульный тест (Unit test) представляет собой набор тестовых функций (обычно - методов тестового класса) для тестирования какого-то программного модуля, в том числе – для тестирования класса. Модульное тестирование преследует следущие основные цели :
* поиск и устранение ошибок;
* верификация проекта;
* поддержка улучшения кода модуля (инструмент рефакторинга);
* документирование модуля;
* разработка модуля (в контексте разработки через тестирование (TDD)) и т.д.

Разработка через тестирование (Test – Driven Development, TDD) – применяемая в экстремальном программировании (XP) практика разработки программных модулей, при которой вначале создаются модульные тесты, а затем - сами модули. Точнее сказать, процесс разработки выполняется как цикл из трех чередующихся шагов: 1) создание / модификация теста; 2) создание / модификация модуля; 3) улучшение кода модуля (рефакторинг), снова создание / модификация теста и т.д. Для данного цикла используется метафора светофора : вначале создается или изменяется тест, запускается компиляция, которая завершается неудачей, так как отсутствует необходимый код в разрабатываемом модуле (“желтый свет”), затем добавляется необходимый для успешной компиляции код, программа компилируется, но тесты не проходят (“красный свет”), затем в модуль добавляется необходимый код, тесты проходят успешно (“зеленый свет”). После этого выполняется улучшение кода (рефакторинг), сопровождаемое постоянной прогонкой тестов. Таким образом выполняется цикл “красный-зеленый-рефакторинг”. (При использовании оболочек тестирования с графическим пользовательским интерфейсом наряду с метафорой светофора используется метафора зеленой и красной полос, которые отображаются в процессе выполнения набора тестов).

В процессе модульного тестирования используются шаблоны (паттерны) тестирования, которые можно рассматривать как рекомендации по различным аспектам тестирования. Шаблоны относятся как к тестированию в целом, так и к конкретным шагам цикла разработки (“шаблоны красной полосы”, “шаблоны зеленой полосы” и пр.) Так, к общим шаблонам относятся шаблоны Тестовые данные, Понятные данные, к шаблонам зеленого света (или “зеленой полосы”) относят шаблоны, используемые для быстрого получения зеленого света, например шаблон Подделка, шаблон Триангуляция, шаблон Очевидная реализация, к шаблонам красного света (или “красной полосы”) относят шаблоны, используемые для нахождения решения при длительном несрабатывании тестов, например шаблон Еще один тест, шаблон Изучающий тест, шаблон Тест одного шага и т.д.

В данной работе изучаются некоторые простые шаблоны, в их числе : 
* Подделка (Fake It) – предполагает использование констант, ожидаемых на выходе тестируемых функций, в качестве возвращаемых этими функциями значений. Этот, на первый взгляд, наивный прием оказывается весьма полезным для того, чтобы быть увереным, что вызывается именно та функция, которую мы ожидаем (это может быть не так, если используется наследование), да и в других случаях...
* Триангуляция (Threeangulation) – предполагает задание двух тестовых проверок, удовлетворить которым можно только используя некий алгоритм (формулу) в коде модуля (“третий угол” треугольника).  
* Тестовые данные (Test Data) – собственно это просто рекомендация относительно тщательного выбора данных для тестовых проверок. 
* Понятные данные (Evident Data) – шаблон, который рекомендует использовать в качестве тестовых данных не константы, а выражения, составленные из констант, по которым можно составить формулы для создаваемого модуля.  
* От одного ко многим – рекомендация по созданию тестов для модулей, обрабатывающих списки, реализующих итерационные алгоритмы и пр. как последовательности тестовых проверок для одного, двух, трех и более элементов списка.
* Очевидная реализация - рекомендация говорит о том, что когда реализация очевидна, ее нужно выполнить.
* Изолированный тест - рекомендация утверждает, что тесты должны быть независимы друг от друга, а тестируемые модули – изолированы от других модулей и внешних данных, не относящихся к тесту.
* Еще один тест – для перехода к реализации следующей функции, выяснения неясных деталей, уточнения контракта модуля и т.д. нужно создать новый тест.
* Тест одного шага - когда не удается обнаружить ошибку и неясно, в какой момент она возникает, нужно сделать более мелкие шаги и создать для них отдельные тесты (проверки).
* Регрессионный тест – тест, создаваемый при обнаружении факта ошибки в процессе эксплуатации модуля для ее локализации и исправления. Добавляется к общему списку тестов.

## 3. Библиотека NUnit

На практике для модульного тестирования часто используют семейство оболочек тестирования xUnit, которые реализованы для многих существующих языков программирования и средств разработки. В данной работе рассматривается open-source оболочка NUnit для проектов, реализованных на платформе .NET. Оболочка (и бибиотека классов NUnit) предполагает использование разработчиком классов - наборов тестовых методов (Tests). Пользователь создает свои тестовые наборы, используя специальные атрибуты .NET для классов и методов ([TextFixture] – для класса-набора, [Test] – для публичного тестового метода, входящего в набор, [SetUp] – метод класса для инициализации, выполняемой перед каждым тестом, [TearDown] - метод класса для очистки даных, выполняемой после каждого теста и др.) В качестве методов для выполнения проверок используются методы библиотечного класса Assert оболочки NUnit, которые вызывают остановку выполнения тестового метода с выдачей информации о месте ошибки в программе и сообщения о ней, если указанное в качестве параметра методов условие не выполняется. Чаще всего используется метод Assert.AreEqual (<Ожидаемое значение>, <Проверяемое значение>, [Дельта]), для сравнения двух величин с возможным указанием допустимой величины расхождений. При несовпадении величин с учетом указанного расхождения метод останавливается, печатаются ожидаемое и реальное значения, номер строки в программе. Реже используются методы Assert.IsTrue(<bool>) и Assert.IsFalse(<bool>). 

Для выполнения тестирования необходимо указать оболочке файл со сборкой .NET. Оболочка по метаданным .NET и атрибутам тестовых классов и методов составляет список тестов (точнее – список списков) для данной сборки .NET (тесты прикомпилируются к основному проекту). При запуске набора тестов оболочка отслеживает их выполнение, сбои, выдает список и информацию о сбоях, общее количество удачных и неудачных тестов, время тестирования, выдает предусмотренную разработчиком отладочную печать и пр.

Оболочка позволяет создавать общий список для нескольких сборок из разных проектов с помощью т.н. файлов проектов NUnit c расширением *.nunit, работать с конфигурационными файлами .NET проектов и т.д.

## 4. Примеры модульных тестов и разработки через тестирование 

### 4.1 Примеры в презентациях

В данной работе необходимо рассмотреть примеры из трех презентаций : 1) пример из лекций (поиск максимума в массиве); 2) поиск медианного значения в списке; 3) разработка небольшого приложения со статистикой по зарплате. 

### 4.2 Пример составления модульных тестов из документации NUnit

Этот пример из документации к NUnit иллюстрирует создание модульного теста для NUnit и работу с ним. Допустим, мы имеем класс Account (счет) для некоторого банковского приложения : 
```c#
namespace bank
{
  public class Account
  {
    private float balance;
    public void Deposit(float amount)
    {
      balance+=amount;
    }

    public void Withdraw(float amount)
    {
      balance-=amount;
    }

    public void TransferFunds(Account destination, float amount)
    {
    }

    public float Balance
    {
      get{ return balance;}
    }
  }
}
```

Теперь создадим тестовый класс AccountTest. Cначала протестируем метод TransferFunds (тем самым мы проиллюстрируем разработку метода через тест) :
```c#
namespace bank
{
  using NUnit.Framework;

  [TestFixture]
  public class AccountTest
  {
    [Test]
    public void TransferFunds()
    {
      Account source = new Account();
      source.Deposit(200.00F);
      Account destination = new Account();
      destination.Deposit(150.00F);

      source.TransferFunds(destination, 100.00F);
      Assert.AreEqual(250.00F, destination.Balance);
      Assert.AreEqual(100.00F, source.Balance);
    }
  }
}
```

Обратите внимание на атрибут [TestFixture], указывающий оболочке, что класс AccountTest является тестовым классом, а также атрибут [Test] у единственного пока тестового метода TransferFunds. Тестовый метод должен быть публичным, возвращать void и не иметь параметров. Тестовые проверки в теле метода выполняются с помощью методов AreEqual библиотечного класса Assert. В данном варианте метода (у него есть перекрытые версии) первый параметр – ожидаемое значение, второй – проверяемое. Скомпилируем пример и получим файл bank.dll. Теперь откроем этот файл в GUI – приложении NUnit (меню File – Open). В списке тестов в окне слева отобразится пространство имен bank, имя тестового класса AccountTest и единственный пока тест TransferFunds. Нажмем кнопку Run и увидим красную полосу и сообщение (в панели Errors and Failures) : 

> TransferFunds : expected <250> but was <150>

Снизу в панели отображается стек вызовов с указанием места ошибки (строки исходного кода) :

> at bank.AccountTest.TransferFunds() in C:\nunit\BankSampleTests\AccountTest.cs:line 17
 
Тест не прошел, так как метод TransferFunds класса Account еще не реализован. Не закрывая тестовую оболочку, переключимся в наше средство разработки (VS2005) и добавим код в данный метод : 

```c#
public void TransferFunds(Account destination, float amount)
{
	  destination.Deposit(amount);
	  Withdraw(amount);
}
```

Перекомпилируем сборку и переклдючимся в оболочку для тестов – сборка автоматически перезагрузилась и готова к тестированию. Нажимаем кнопку Run и видим теперь зеленую полосу.
Добавим теперь дополнительную функциональность в наш класс Account. Введем атрибут (и свойство) минимального разрешенного баланса счета и будем его проверять :

```c#
private float minimumBalance = 10.00F;
public float MinimumBalance
{
	 get{ return minimumBalance;}
}
```

При уменьшении баланса меньше этого предела будем генерировать исключение :

```c#
namespace bank
{
   using System;
   public class InsufficientFundsException : ApplicationException
   {
   }
}
```

Добавим еще один тестовый метод в наш класс AcoountTest :
```c#
[Test]
[ExpectedException(typeof(InsufficientFundsException))]
public void TransferWithInsufficientFunds()
{
	Account source = new Account();
	source.Deposit(200.00F);
	Account destination = new Account();
	destination.Deposit(150.00F);
	source.TransferFunds(destination, 300.00F);
}
```

В данном случае мы не используем класс Assert, но вместо этого используем атрибут ExpectedException, который сообщает оболочке о том, что при выполнении кода тестового метода ожидается указанное исключение. Скомпилируем наш проект и опять переключимся на тестовую оболочку. В списке появились два тестовых метода. Нажимаем Run и получаем красную полосу с сообщением : 

> TransferWithInsufficentFunds : InsufficientFundsException was expected

Чиним тест – исправляем код метода TransferFunds :
```c#
public void TransferFunds(Account destination, float amount)
{
	 destination.Deposit(amount);
	 if(balance-amount<minimumBalance)
		throw new InsufficientFundsException();
	 Withdraw(amount);
}
```

Компилируем и запускаем тесты – зеленая полоса ! Но если присмотреться к нашему коду, то мы увидим, что банк будет терять деньги при каждой неудачной операции перевода. Чтобы проверить наши опасения мы создаем еще один тест : 
```c#
[Test]
public void TransferWithInsufficientFundsAtomicity()
{
        Account source = new Account();
        source.Deposit(200.00F);
        Account destination = new Account();
        destination.Deposit(150.00F);
        try
        {
                source.TransferFunds(destination, 300.00F);
        }
        catch(InsufficientFundsException expected)
        {
        }

        Assert.AreEqual(200.00F,source.Balance);
        Assert.AreEqual(150.00F,destination.Balance);
}
```

После компиляции и проверки мы получаем красную полосу. Теперь нам нужно решить, как мы будем поддерживать атомарность наших транзакций. Мы можем перенести вызов метода Deposit после проверки на минимальный баланс в методе TransferFunds, однако, что произойдет в случае исключения при выполненнии Withdraw? Как обеспечить атомарность транзакций? Стоит ли использовать блок try ... catch и компенсировать неудачные транзакции, или следует поручить обработку ошибок классу Менеджер транзакций? Мы пока не знаем. Что же делать с тестом, убрать из списка? Вместо этого решаем игнорировать его выполнение пока, для этого используем специальный атрибут: 
```c#
[Test] 
[Ignore("Decide how to implement transaction management")]
public void TransferWithInsufficientFundsAtomicity() 
```

Компилируем и запускаем набор тестов – получаем зеленую полосу. Перейдя на закладку TestsNotRun мы видим список не запускавшихся тестов из одного пункта - TransferWithInsufficientFundsAtomicity с указанием причины.

Обращаем внимание на то, что наш тестовый код содержит повторы, во всех тестах используется одинаковый инициализирующий код. Выносим его в отдельный метод Init и помечаем его атрибутом [SetUp] :
```c#
namespace bank
{
  using System;
  using NUnit.Framework;

  [TestFixture]
  public class AccountTest
  {
    Account source;
    Account destination;

    [SetUp]
    public void Init()
    {
      source = new Account();
      source.Deposit(200.00F);
      destination = new Account();
      destination.Deposit(150.00F);
    }

    [Test]
    public void TransferFunds() {
      source.TransferFunds(destination, 100.00f);
      Assert.AreEqual(250.00F, destination.Balance);
      Assert.AreEqual(100.00F, source.Balance);
    }

    [Test]
    [ExpectedException(typeof(InsufficientFundsException))]
    public void TransferWithInsufficientFunds(){
      source.TransferFunds(destination, 300.00F);
    }

    [Test]
    [Ignore("Decide how to implement transaction management")]
    public void TransferWithInsufficientFundsAtomicity()
    {
      try {
        source.TransferFunds(destination, 300.00F);
      }
      catch(InsufficientFundsException expected)
      {}
      Assert.AreEqual(200.00F,source.Balance);
      Assert.AreEqual(150.00F,destination.Balance);
    }
  }
}
```

Запускаем компиляцию и тестирование – зеленая полоса.

### 4.3 Пример разработки функции вычисления последовательности Фибоначчи в стиле TDD 

Рассмотрим пример разработки через тестирование – вычисление последовательности Фибоначчи. Этот пример приводится в книге К. Бека “Экстремальное программирование: разработка через тестирование”. Пример приводится на языке Java (его легко реализовать и на C#, подобное преобразование вы можете выполнить самостоятельно :)). На всякий случай напоминаем : последовательность Фибоначчи – это ряд чисел 0, 1, 1, 2, 3, 5, 8, 13 и так далее, то есть – каждый последующий член ряда, начиная с третьего (нумерация идет с 0) есть сумма двух предыдущих, нулевой элемент = 0, первый = 1.	Первый тест показывает, что fib(0) = 0, реализация возвращает константу (шаблон Подделка):
```c#
public void testFibonacci() {
    assertEquals(0, fib(0));
}
int fib(int n) {
    return 0;
}
```	

(Класс TestCase используется как место для размещения разрабатываемой функции, так как она всего одна.) 
Второй тест показывает, что fib(1) = 1.
```c#
public void testFibonacci() {
    assertEquals(0, fib(0));
    assertEquals(1, fib(1));
}
```

Для дополнительной проверки нет смысла создавать отдельный метод, поэтому просто добавляем еще один вызов assertEquals. 

Чтобы заставить функцию работать, используем 0 как специальный случай :
```c#
int fib(int n) {
    if (n==0) return 0;
    return 1;
}
```

Дублирования следует избегать не только при создании модулей, но и при создании тестов, поэтому избавимся от дублирования, проведя рефакторинг теста (добавим таблицу аргументов и ожидаемых значений функции): 
```c#
public void testFibonacci() {
    int cases[][] = {{0,0}, {1,1}};
    for (int i=0; i < cases.length; i++)
            assertEquals(cases[i][1], fib(cases[i][0]));
}
```

Теперь добавление нового теста не составит труда : 
```c#
public void testFibonacci() {
    int cases[][] = {{0,0}, {1,1}, {2,1}};
    for (int i=0; i < cases.length; i++)
            assertEquals(cases[i][1], fib(cases[i][0]));
}
```
Этот тест срабатывает, поскольку возвращаемая константа (1) подходит и на этот раз. Один из принципов TDD говорит о том, что перед добавлением новой функциональности необходимо сломать тест. Добавляем новую проверку, используя шаблоны Триангуляция и Тестовые данные :
```c#
int cases[][] = {{0,0}, {1,1}, {2,1}, {3,2}};
```
Тест не сработал! Как и раньше, добавляем специальный случай: 
```c#
int fib(int n) {
    if (n==0) return 0;
    if (n<=2) return 1;
    return 2;
}
```
Теперь можно обобщить код (устраняем дублирование). Мы написали 2, но имели в виду 1 + 1. Первая единица в сумме – это на самом деле fib(n – 1), а вторая – это fib(n -2) : 
```c#
int fib(int n) {
    if (n==0) return 0;
    if (n<=2) return 1;
    return fib(n-1) + fib(n-2);
}
```
Улучшаем код : 
```c#
int fib(int n) {
    if (n==0) return 0;
    if (n==1) return 1;
    return fib(n-1) + fib(n-2);
}
```

Итак, мы получили функцию Фибоначчи, пользуясь TDD.
Здесь я бы позволил себе сделать пару замечаний к примеру К.Бека : 
1) Переход к fib(n-1) + fib(n-2) не совсем очевиден, здесь можно предложить использовать шаблон От Одного Ко Многим, добавив еще 1-2 тестовых значения, которые позволят легче выполнить обобщение.
2) Полученная функция вполне вероятно не является лучшей с точки зрения быстродействия, можно, например, отказаться от рекурсии. Но здесь главное не быстродействие, а прозрачность кода и принципы его разработки.	


### 4.4 Пример разработки через тестирование для задачи с расчетом кредита

В соответствии с планом первой итерации рассмотрим реализацию первого прецедента нашего проекта по расчету кредита.

П1 Расчет платежа по кредиту за указанный период и среднемесячного платежа
Системе сообщается годовая процентная ставка, сумма кредита и количество месяцев (срок), на который он берется. Система рассчитывает сумму начисляемых за все время пользования кредитом процентов с учетом ежемесячного погашения кредита равными долями и общую сумму выплат. Затем система расчитывает среднемесячную сумму выплат.

В нем, согласно модели предметной области, участвует только один концептуальный класс – РасчетКредита (calcCredit). Давайте назовем его все-таки просто Credit. Если рассмотреть прецедент с точки зрения системной операции, получим следующую диаграмму последовательности : 
```
 --------------                       --------------
|              |                     |              |
| Пользователь |                     |    Система   |
|              |                     |              |
 ------   -----                       --------------
       | |                                   : 
       | |                                   : 
       | |                                   : 
       | |                                   : 
       | |         setSum(double s)          :
       | |--------------------------------->| |
       | |                                  | |
       | |         setTerm(int t)           | |
       | |--------------------------------->| |
       | |                                  | |
       | |        setPercent(double p)      | |
       | |--------------------------------->| |
       | |                                  | |
       | |         getTotalPayment()        | |
       | |--------------------------------->| |
       | |<- - - - - - - - - - - - - - - - -| |
       | |          TotalPayment            | |
       | |                                  | |
       | |                                  | |
       | |         getExtraPayment()        | |
       | |--------------------------------->| |
       | |<- - - - - - - - - - - - - - - - -| |
       | |          ExtraPayment            | |
       | |                                  | |
       | | getAverageMonthPayment(double p) | |
       | |--------------------------------->| |
       | |<- - - - - - - - - - - - - - - - -| |
       | |       AverageMonthPayment        | |
       | |                                   :
       | |                                   :
```

Достаточно очевидно, что общая сумма выплат включает сумму оплаты процентов, а сумма среднемесячного платежа рассчитывается из общей суммы выплат :
```c#
TotalPayment = Sum + ExtraPayment 					(1)

AverageMonthPayment = TotalPayment / Term	(при Term > 0)	(2) 
```
Итак, мы можем определить публичный интерфейс нашего класса : 
```
 ----------------------------------
|               Credit             | 
|----------------------------------|
| setTerm(t: int): void            |
| setPercent(p: double): void      |
| setSum(s: double): void          |
| getExtraPayment(): double        |
| getTotalPayment(): double        |
| getAverageMonthPayment(): double |
 ----------------------------------
```
	
Учитывая, что мы реализуем класс на C#, мы можем использовать свойства (properties) для доступа к Sum, Term и Percent : 
```
 ----------------------------------
|               Credit             | 
|----------------------------------|
| Term: int                        |
| Percent: double                  |
| Sum: double                      |
|----------------------------------|
| getExtraPayment(): double        |
| getTotalPayment(): double        |
| getAverageMonthPayment(): double |
 ----------------------------------
```

У нас есть достаточно информации для начала разработки класса, используя методику TDD.	
Приступим к разработке нашего класса, который будет расчитывать выплаты по кредиту. В исходном плане из 1 лабораторной работы можно раскрыть пункты, касающиеся собственно разработки класса, до уровня реализуемых тестов и методов (это напоминает план на уровне дня) : 
...        
7.	Создание модульных тестов
8.	Разработка класса с алгоритмом расчета
...

Поскольку мы используем разработку через тестирование, разделять разработку тестов и модулей не стоит : 

1.	Тест создания класса и обращения к методам класса после создания.
2.	Тест установки и считывания атрибутов
3.	Тест нулевого кредита (полезно проверить краевые значения !)
4.	Тест кредита с нулевыми процентами.
5.	Тест кредита с процентами, взятого на один месяц
6.	Тест кредита с процентами на три месяца

Есть надежда, что после реализации этого списка тестов мы получим нужный нам класс для расчета платежей (поскольку мы только знакомимся с TDD, используем мелкие шаги). 
Для начала составим тест создания объекта и проверки его свойств : 

```c#
[TestFixture]
public class CreditTestCase
{
    [Test]
    public void testCreate()
    {
        Credit c = new Credit(1000, 3, 20);
        Assert.AreEqual(1000, c.Sum);
        Assert.AreEqual(3, c.Term);
        Assert.AreEqual(20, c.Percent);
    }
}
```

Пусть в конструкторе инициализируются сумма, срок и годовой процент. Проверяем, что класс создался и его атриубты имеют соответствующее значение. Компиляция завершается неудачно, так как у нас нет ни класса, ни методов. (Желтый сигнал светофора). Создаем класс с нужными методами и свойствами и помещаем его в файл Credit.cs :

```c#
namespace CalcCredit
{
    public class Credit
    {
        public Credit(double s, int t, double p)
        {}

        public double Sum 
        {
            get { return 0; }
            set { }
        }

        public int Term
        {
            get { return 0; }
            set { }
        }

        public double Percent
        {
            get { return 0; }
            set { }
        }
    }
}
```

Обратите внимание, что мы не только не реализовали конструктор, но даже не завершили описание свойств Sum, Term и Percent. Теперь проект компилируется, но мы получаем красный свет, так как не реализовали нужную функциональность.
Добавляем ее : добавляем закрытые атрибуты (поля) и инициализируем их в конструкторе, а потом возвращаем в аксессорах get: 
```c#
public class Credit
{
    double sum, percent;
    int t;

    public Credit(double s, int t, double p)
    {
        sum = s;
        term = t;
        percent = p;
    }

    public double Sum 
    {
        get { return sum; }
        set { }
    }

    public int Term
    {
        get { return term; }
        set { }
    }

    public double Percent
    {
        get { return percent; }
        set { }
    }
}
```
Нам для данного теста нужны только аксессоры для чтения свойств, а не для записи. Теперь все работает! Мы можем вычеркнуть один пункт из плана. Мы уже выполнили 15 процентов работы :).

Пишем второй тест: 
```c#
[Test]
public void testSetGet () {
    Credit c = new Credit(1000, 3, 20);
    c.Sum = 2000;
    c.Term = 6;
    c.Percent = 25;
    Assert.AreEqual(2000, c.Sum);
    Assert.AreEqual(6, c.Term);
    Assert.AreEqual(25, c.Percent);
}
```

Теперь мы можем пропустить желтый свет и сразу реализовать нужную функциональность в нашем классе (ведь все довольно просто - мы просто добавляем код вида sum = value в соответствующие аксессоры set ) : 
```c#
...
set { sum = value; }
...
set { term = value; }
...
set { percent = value; }
...
```
Имеем уже 2 срабатывающих теста ...

Создаем третий тест (проверяем работу с нулевыми значениями) : 
```c#	
[Test]
public void testZeroCreditPayment() {
    Credit c = new Credit(0, 3, 20);
    Assert.AreEqual(0, c.getExtraPayment());
    Assert.AreEqual(0, c.getTotalPayment());
    Assert.AreEqual(0, c.getAverageMonthPayment());
    c.Term = 12;
    Assert.AreEqual(0, c.getExtraPayment());
    Assert.AreEqual(0, c.getTotalPayment());
    Assert.AreEqual(0, c.getAverageMonthPayment());
    c.Term = 6;
    c.Percent = 10;
    Assert.AreEqual(0, c.getExtraPayment());
    Assert.AreEqual(0, c.getTotalPayment());
    Assert.AreEqual(0, c.getAverageMonthPayment());
    c.Term = 0;
    Assert.AreEqual(0, c.getExtraPayment());
    Assert.AreEqual(0, c.getTotalPayment());
    Assert.AreEqual(0, c.getAverageMonthPayment());
    c.Term = 6;
    c.Percent = 0;
    Assert.AreEqual(0, c.getExtraPayment());
    Assert.AreEqual(0, c.getTotalPayment());
    Assert.AreEqual(0, c.getAverageMonthPayment());
    c.Term = 0;
    Assert.AreEqual(0, c.getExtraPayment());
    Assert.AreEqual(0, c.getTotalPayment());
    Assert.AreEqual(0, c.getAverageMonthPayment());
}
```
С третьим тестом также не возникает проблем: чтобы он заработал, нам нужно всего лишь добавить описание трех тривиальных методов в класс: 
```c#
public double getExtraPayment()
{
    return 0;
}

public double getTotalPayment()
{
    return 0;
}

public double getAverageMonthPayment()
{
    return 0;
}
```
Это может показаться смешным, но наш класс уже правильно считает выплату по кредиту! Правда, только по нулевому ... 

Пишем тест для кредита без процентов. Тут нужно остановиться. Сначала делаем первую проверку :  
```c#	
[Test]
// Кредит без процентов
public void testZeroPercentsPayment() 
{
    Credit c = new Credit(1000, 10, 0);
    Assert.AreEqual(0, c.getExtraPayment());
    Assert.AreEqual(1000, c.getTotalPayment());
    Assert.AreEqual(100, c.getAverageMonthPayment());
}
```

Тест не проходит. Немного непонятно, с чего начинать изменение класса ... На помощь приходит шаблон Подделка - меняем методы getTotalPayment() и getAverageMonthPayment() следующим образом : 
```c#
public double getTotalPayment()
{
    return 1000;
}

public double getAverageMonthPayment()
{
    return 100;
}
```
Тест номер 4 сработал! Однако, перестал работать тест номер 3 – теперь при нулевом размере кредита возвращается не ноль. Пытаемся разрешить нашу проблему “в лоб” :
```c#
public double getTotalPayment()
{
    if (term != 0)
        return 1000;
    else
        return 0;
}

public double getAverageMonthPayment()
{
    if (term != 0)
        return 100;
    else
        return 0;
}
```

Наш класс теперь содержит два фрагмента повторяющегося кода. 
И хотя все тесты срабатывают, но интуитивно понятно, что здесь что-то не так. Применяем шаблон Триангуляция и добавляем в тест еще несколько строк: 
```c#
c.Term = 5;
Assert.AreEqual(0, c.getExtraPayment());
Assert.AreEqual(1000, c.getTotalPayment());
Assert.AreEqual(200, c.getAverageMonthPayment());
```
Тест “сломался”.

Приходится немного подумать, почему при уменьшении вдвое срока кредита сумма выплат увеличилась вдвое и применить шаблон Очевидная реализация, а также формулу (2) : 
```c#
public double getTotalPayment()
{
    return sum;
}

public double getAverageMonthPayment()
{
    if (term > 0)
        return getTotalPayment() / term;
    else
        return 0;
}
```
Теперь все четыре теста срабатывают и все выглядит отлично :).

Пора переходить к серьезной работе - составляем тест для одного месяца, но с процентами : 
```c#
[Test]
// Кредит на 1 месяц с процентами 
public void test1MonthCreditPayment()
{
    Credit c = new Credit(1000, 1, 12);
    Assert.AreEqual(10, c.getExtraPayment());
}
```
Мы опять в затруднении – как же реализовать метод getExtraPayment()? Ведь не совсем очевидно, как получить из этих трех исходных чисел такой результат. На помощь приходит шаблон Понятные данные. Меняем тест. Как собственно мы получили число 10? Мы выполнили такой расчет : 1000 * 12 * 0.01 / 12. Почему бы нам не задать ответ имененно в таком виде?
```c#
    Assert.AreEqual(1000 * 12 * 0.01 / 12, c.getExtraPayment());
```

Теперь так делаем и в самом классе : 
```c#
public double getExtraPayment()
{
	return sum * 0.01 * percent / 12;
}
```
Тесты проходят. Добавим еще несколько строк для проверки getTotalPayment() и getAverageMonthPayment() :
```c#
    Assert.AreEqual(c.getExtraPayment() + c.Sum, c.getTotalPayment());
    Assert.AreEqual(c.getTotalPayment(), c.getAverageMonthPayment());
```
Тест не проходит из-за первой проверки – меняем код метода getTotalPayment() в соответствии с приведенной проверкой и формулой (1) :
```c#
	return getExtraPayment() + sum;
```
Тест сработал. Чтобы удостовериться, что за один месяц все считается правильно, выполняем еще одну проверку :
```c#
    // А это любимые всеми нами 29 годовых :)
    Credit c1 = new Credit(1000, 1, 29);
    Assert.AreEqual(1000 * 0.01 * 29 / 12, c1.getExtraPayment());
    Assert.AreEqual(c1.getExtraPayment() + c1.Sum, c1.getTotalPayment());
    Assert.AreEqual(c1.getTotalPayment(), c1.getAverageMonthPayment());
```
Эта проверка также проходит успешно и мы переходим к самой ответственной части : к тесту кредита за три месяца. 
Сначала мы пробуем идти проторенной дорогой - используем шаблон Понятные данные и задаем тест расчета для 3 месяцев : 
```c#
// Кредит на 3 месяца с процентами 
public void test3MonthsCreditPayment()
{
    // Продолжаем использовать Evident Data 
    // - сначала посмотрим, что будет для 2 месяцев :
    // А как посчитать?!! - Делаем по индукции ...
    Credit c = new Credit(1000, 2, 12);
    Assert.AreEqual(1000*0.12 / 12 + 500*0.12 / 12, c.getExtraPayment());
    Assert.AreEqual(1000 + c.getExtraPayment(), c.getTotalPayment());
    Assert.AreEqual((1000 + c.getExtraPayment()) / 2, c.getAverageMonthPayment());
}
```

Для прохождения этого теста мы сначала можем задать соответствующую формулу в методе getExtraPayment(). Затем мы можем перейти к 3 месяцам и воспользоваться шаблонами Триангуляция и От Одного ко Многим :
```c#
    c.Term = 3;
    Assert.AreEqual( 1000 * 0.12 / 12 +
                    1000 *(1 - 1 / 3) * 0.12 / 12 +
                    1000 / 3 * 0.12 / 12, c.getExtraPayment());
    Assert.AreEqual(1000 + c.getExtraPayment(), c.getTotalPayment());
    Assert.AreEqual((1000 + c.getExtraPayment()) / 2, c.getAverageMonthPayment());
```
Выполнив триангуляцию, получаем сначала такой код в методе getExtraPayment() : 
```c#
    if (term == 1)
    {
    return sum * 0.01 * percent / 12;
    }
    else if (term == 2) {
        return (sum + sum / 2) * 0.01 * percent / 12;
    }
    else {
        return (sum + 2 * sum / 3 + sum / 3) * 0.01 * percent / 12;
    }
```
а затем – такой : 
```c#
    double total = 0; // хранение общей суммы переплаты
    // добавляем проценты :
    for (int i = 0; i < term; i++)
    {
        total += (sum - i * sum / term) * (0.01 * percent / 12);
    }
return total;
```
Тут выясняется одно неприятное обстоятельство : тест все равно не проходит !
Мы пытаемся понять, в чем дело и обращаемся к сообщению, выданному методом Assert.AreEqual() :

> CalcCredit.CreditTestCase.test3MonthsCreditPayment : 
>		expected: <23,329999999999998>
>		but was: <20>

Выясняется, что исходные данные для теста были не верны! Действительно, если вычислить реальную сумму переплаты, то она должна была составить (1000 + 1000) * 0.12 / 12 = 20. Ошибка допущена в тестовом выражении : вместо 1 - 1 / 3 следовало написать, например, (1 - 1.0 / 3), а также можно указать, с какой точностью мы хотим проверить результат с плавающей запятой (могут быть погрешости).

Наша проверка получилась довольно трудночитаемой и не очень понятной, поэтому в результате лучше перейти к более легко читаемой проверке (по шаблону Тестовые данные) : 
```c#
      Assert.AreEqual(20, c.getExtraPayment(), 0.001);
      Assert.AreEqual(1020, c.getTotalPayment(), 0.001);
      Assert.AreEqual(340, c.getAverageMonthPayment(), 0.001);
```
Ситуация, которую мы получили, вполне типичная – зачастую мы не можем что-то отладить просто потому, что сравниваем с неверным результатом ! Не нужно об этом забывать.

Создадим прототип приложения, содержащего наш класс расчета. Оно будет пока консольным и будет реализовывать в целом ту же последовательность действий, которая задается соответсвующей диаграммой UML.
	Посмотрим на наш уточненный и детализированный план итерации :

	Задачи :

	П1.1 Расчет полного платежа по кредиту и среднемесячного платежа
	1. Составление плана итерации 
	2. Создание проекта и инфраструктуры 
	3. Создание эскизного проекта архитектуры 
	4. Изучение особенностей средства разработки
	5. Изучение оболочки для тестирования
	6. Создание приемочного теста
	7. Тест создания класса и обращения к методам класса после создания.
	8. Тест установки и считывания атрибутов
	9. Тест нулевого кредита (полезно проверить краевые значения !)
	10. Тест кредита с нулевыми процентами.
	11. Тест кредита с процентами, взятого на один месяц
	12. Тест кредита с процентами на три месяца
	13. Разработка приложения
	14. Оценка скорости разработки, планирование (в том числе текущее) 

Итак, мы выполнили примерно 11 пунктов из 14, что составляет почти 79%. А выполняемая сейчас оценка скорости разработки и текущее планирование позволяет нам добавить еще один пункт, тогда получаем 86%. Не выполнены только два пункта первоначального плана : эскиз архитектуры и приемочный тест. Насчет последнего можно отметить, что в качестве такого теста вполне подойдет пока наш последний тест из набора (кредит на 3 месяца). Что же касается архитектурного проекта, то действительно, пока его нет. Разве что можно сослаться на трехслойную модель, из которой мы пока реализовали представителя слоя предметной области и элементы слоя UI в основном запускающем приложении. Последнее, однако, является консольным, а не GUI. Не совсем понятно пока наполнение третьего слоя...

Даже несмотря на некоторый пробел в анализе архитектуры мы в общем достигли определенных успехов при реализации первой итерации. С другой стороны следует признать, что наш первоначальный план на итерацию был уж слишком легким для выполнения.

Поскольку мы практически все реализовали, а время и силы еще остались (:) ), рассмотрим дополнительные задачи. Мы можем взяться за задачи второй итерации. Что реализовывать : доступ к БД за параметрами кредитов (пока это только годовой процент) или определение списка помесячных платежей при неравномерных (неусредненных) выплатах ?

Нас больше интересует с точки зрения архитектуры нашего приложения первая задача. Поскольку для заказчика они обе эквивалентны (обе помещены во 2 итерацию им самим), а для нас важнее первая, выберем ее. 

Кроме того, нас ожидает первая новость, касающаяся изменения (расширения) требований. Заказчик, прослышав о наших успехах, передал нам пожелание о поддержке варианта расчета «от обратного» : когда указывается не срок кредита, а наоборот, желаемая ежемесячная сумма платежа, а срок вычисляется (такой расчет уже предлагают конкурирующие кредитные организации). Попробуем реализовать это пожелание, тем более, что его реализация кажется несложной задачей.

Сначала займемся как раз вот этим дополнительным пожеланием. Не нужно проводить долгий анализ, чтобы выяснить, что для его реализации нужно расширить интерфейс класса Credit таким образом, чтобы он включал еще и свойство DesiredPayment (желаемый платеж) : 
	







Создадим один дополнительный тест (кажется, одного должно хватить) :
```c#
[Test]
public void testDesiredAveragePayment()
{
    // От одного ко Многим ...
    // Альтернативный конструктор
    Credit c = new Credit(1000, 1010.0, 12);
    Assert.AreEqual(1, c.Term);
    Assert.AreEqual(1010, c.getTotalPayment());
    c.DesiredPayment = 507.5;
    Assert.AreEqual(2, c.Term);
    Assert.AreEqual(1015, c.getTotalPayment());
    c.DesiredPayment = 340.0;
    Assert.AreEqual(3, c.Term);
    Assert.AreEqual(1020, c.getTotalPayment());
}
```
В этом тесте, как видно, мы решили воспользоваться уже опробованным способом создания кода по индукции («от одного ко многим»).

Сначала мы опять получаем «желтый» сигнал, поскольку еще не реализовали ни новый вариант конструктора, ни публичное свойство DesiredPayment. Добиваемся удачной компиляции, создав необходимые метод и свойство : 
```c#
    public class Credit
    {
        double sum, percent, desired_mnth_paym;
        int term;

        ...

        public Credit(double s, double paym, double p)
        {
            sum = s;
            percent = p;
            desired_mnth_paym = paym;
        }

        ...	

        public double DesiredPayment
        {
            get
            {
                return desired_mnth_paym;
            }
            set
            {
                desired_mnth_paym = value;
            }
        }
    }
```
Получаем красный свет (красную полосу). Что теперь ? Можно воспользоваться подделкой, либо триангуляцией, но почему-то сразу приходит в голову (эврика !) следующая формула : 
```c#	
      term = Convert.ToInt32(getTotalPayment() / desired_mnth_paym);
```
Куда ее поместить ? Поскольку она относится к Term и в коде теста мы всегда сначала определяем Term, а потом – все остальное (в данном случае – getTotalPayment()), мы решаем поместить эту формулу в код аксессора get() для свойства Term :
```c#
public int Term
{
    get 
    {
        if (desired_mnth_paym != 0)
        {
        term = Convert.ToInt32(getTotalPayment() / desired_mnth_paym);
    }
        return term; 
    }
    set { term = value; }
}
```

Запускаем тест – он срабатывает ! Это кажется практически невероятным, но это так. Казалось бы, все отлично. Но закрадываются сомнения (есть подозрения, что этот алгоритм слишком прост, чтобы быть правдой), и чтобы их устранить, создаем Еще один тест (кстати, это название одного из шаблонов модульного тестирования). Для этого не обязательно создавать новый тестовый метод, просто добавляем в него проверку : 
```c#
// Возьмем срок подольше и процент побольше ...
c = new Credit(1000, 5, 60);
Console.WriteLine(c.getAverageMonthPayment()); // 230
c = new Credit(1000, 230.0, 60);

Assert.AreEqual(5, c.Term);  
Assert.AreEqual(1150, c.getTotalPayment());  
```
Запускаем обновленный тест – не работает ! Как и следовало ожидать, удача в первых трех проверках – не более, чем совпадение... Ничего путного в голову не приходит, зависимость срока от параметров кредита теперь кажется довольно сложной... Что же делать?

Обратите внимание на код теста – чтобы не высчитывать вручную тестовые данные для большего числа месяцев и “незнакомого” нам (по прошлым тестам) процента, мы воспользовались уже полученной ранее функциональностью класса и просто подставили результат вместо исходных данных. А почему бы не воспользоваться этим приемом и в самом классе ? Мы можем использовать ранее полученную формулу в качестве отправной точки, а затем заняться подбором с помощью getAverageMonthPayment(). Пусть не очень красиво, но должно сработать : 
```c#
public int Term
{
    get 
    {
        if (desired_mnth_paym != 0)
        {
            // Расчитываем от обратного ...
            // Решение "в лоб" - подбор ! - Навеяно тестом !
            term = Convert.ToInt32(
                getTotalPayment() / desired_mnth_paym);
            while (getAverageMonthPayment() > desired_mnth_paym)
            {
                term++;
            }
        }
        return term; 
    }
    set { term = value; }
}
```
И действительно, теперь тест работает. Однако беглый взгляд на него (например, товарища при парном программировании) указывает нам на то, что данный тест определяет контракт использования нашего класса при расчете от обратного следующим образом : после задания DesiredPayment сначала всегда проверяется свойство Term, а потом уже вызывается getTotalPayment() и др. Но мы имели в виду нечто другое – достаточно просто установить это свойство и любой метод сразу даст нам интересующий нас правильный ответ.

Чтобы это проверить, мы задаем три дополнительные проверки : 
```c#
// Уточним контракт класса при использовании желаемой суммы выплат
// Не будем вызывать с.Term ...
c = new Credit(1000, 230.0, 60);
Assert.AreEqual(1150, c.getTotalPayment()); // Не срабатывает !!!

c = new Credit(1000, 230.0, 60);
Assert.AreEqual(150, c.getExtraPayment());  

c = new Credit(1000, 230.0, 60);
Assert.AreEqual(230, c.getAverageMonthPayment());
```
Может возникнуть вопрос : а зачем три раза заново создавать объект с ? Почему нельзя воспользоваться одним и тем же объектом ? Дело в том, что мы не знаем точно, меняется ли состояние объекта после одного вызова, поэтому мы должны изолировать эти три проверки друг от друга (шаблон Изолированный тест). Если же мы хотим удостовериться, что методы не влияют друг на друга, мы можем добавить еще две проверки в конце : 
```c#
c = new Credit(1000, 230.0, 60);
Assert.AreEqual(230, c.getAverageMonthPayment());
Assert.AreEqual(150, c.getExtraPayment());  
Assert.AreEqual(1150, c.getTotalPayment());
```
Тесты не сработали, и мы ищем, в чем причина. Как нетрудно догадаться, причина в том, что мы ошибочно поместили приведенный код подбора в метод get свойства Term, хотя следовало бы поместить в метод set свойства DesiredPayment и использовать именно свойство, а не приватный атрибут класса для инициализации в конструкторе : 
```c#
public Credit(double s, double paym, double p)
{
    sum = s;
    percent = p;
    term = 0;
    DesiredPayment = paym;
}
...
public double DesiredPayment
{
    get
    {
        return desired_mnth_paym;
    }
    set
    {
        desired_mnth_paym = value;
        if (desired_mnth_paym != 0)
        {
            term = Convert.ToInt32(
            getTotalPayment() / desired_mnth_paym);
            while (getAverageMonthPayment() > desired_mnth_paym)
            {
                term++;
            }
        }
    }
}
```
Ну, и, конечно, нужно убрать аналогичный код из метода get свойства Term.

Запускаем тест – он сработал. Запускаем теперь все 7 тестов из нашего набора – они также срабатывают (это немаловажно – не всегда можно с уверенностью сказать, что внесенные изменения не повлияют на уже имеющийся код).

Завершим на время работу над нашим классом (на самом деле, тут есть еще что и как протестировать, но об этом потом :) ).
	
Теперь перейдем к реализации чтения параметров кредитования из БД.

Где разместить код для доступа к БД ? Мы можем воспользоваться либо сразу тестами, либо – провести сначала небольшой сеанс проектирования, в обоих случаях мы придем к выводу, что такой код лучше разместить в отдельном от Credit классе. С точки зрения объектного проектирования размещение кода доступа к БД в классе Credit нарушает принцип SRP. С точки зрения TDD размещение кода доступа к БД в классе Credit затрудняет тестирование класса. Допустим, мы реализуем чтение годовых процентов из БД и их использование непосредственно в классе Credit. Каким образом мы сможем тогда протестировать работу этого класса, ведь мы не знаем, какой процент в момент запуска теста хранится в БД ? С другой стороны, если источник данных будет отсутствовать, протестировать класс Credit вообще не удастся. Конечно, это можно как-то обойти, но в любом случае тестирование будет затруднено. Соотвественно, “то, что сложно протестировать, неправильно спроектировано”.

Для определения интерфейса класса доступа к БД (назовем его пока DataSource) рассмотрим диаграмму взаимодействия метода main() основной программы, объекта класса DataSource и объекта класса Credit (рис.). Поскольку Credit не знает о существовании DataSourcе, управление созданием и использованием объектов этих классов по шаблону Информационный эксперт логично возложить на основную программу. Уточнить эту диаграмму можно, проконсультировавшись с заказчиком (он уточнит желаемый интерактив).

Из данной диаграммы можно получить первоначальный интерфейс нашего класса DataSource :

		





Теперь перейдем к составленнию теста для этого класса. Да, как ни трудно, но все-таки нужно стараться тестировать даже классы, работающие с файлами, базами данных, аппаратурой и пользовательским интерфейсом.

При составлении теста сразу возникает вопрос : как тестировать внешний источник данных, ведь мы ничего не знаем о его состоянии в данный момент ?! Общая стратегия такова : декомпозиция классов, использование интерфейсов и – изолирование тестируемого кода. Изолировать код нужно не только от кода других модулей, но и по возможности – от внешних систем и данных. В данной работе мы только начнем рассмотрение этого вопроса, а в последующих продолжим . Итак, для изолирования DataSource от данных по крайней мере нужно параметризовать класс именем или другими параметрами источника данных, чтобы можно было подставлять вместо реального источника тестовый. Для этого в интерфейс класса добавим имя источника (например, в качестве параметра конструктора) :
```c#	
public DataSource(string s);
```

Составим тесты для нашего источника данных. С чего начать ? Ну, как обычно, можно начать с теста создания. При этом сразу можно проверить, что настоящий физический источник данных (с реальным именем) существует (проходит проверку), а произвольный тестовый – нет. В данном случае физический источник данных – это текстовый файл с разделителями по имени cred_rates.txt, располагающийся в подкаталоге \Data, ODBC драйвер Microsoft для текстовых файлов с разделителями, который мы будем использовать, интерпретирует имя каталога как имя БД.
```c#
[Test]
public void testCreateAndTest()
{
    DataSource ds = new DataSource("?");
    Assert.IsFalse(ds.testOK());

    ds = new DataSource("Data");

    Assert.IsTrue(ds.testOK());
}
```

Следующий тест будет проверять функциональность оставшегося метода нашего класса, в данном случае – это публичное свойство Percent. Собственно, если не предпринимать каких-то дополнительных усилий, мы можем только полагаться на известное нам откуда-то значение (т.н. Магическая константа), которое, как мы предполагаем, хранится в БД : 
```c#    
	  [Test]
        public void testGetData()
        {
            DataSource ds = new DataSource("Data");
            Assert.IsTrue(ds.testOK());
            Assert.AreEqual("29", ds.Percent);
        }
```

Немного отступив от принципов TDD (только для сокращения времени !) мы можем сразу реализовать нужный нам класс, пользуясь только справочными данными и примерами кода, например, так :
```c#
public class DataSource
{
    string ds_name;

    public DataSource(string n)
    {
        ds_name = n;
    }

    public string Percent
    {
        get
        {
            OdbcConnection cnn = new OdbcConnection(
                    "Driver={Microsoft Text Driver (*.txt; *.csv)};DBQ=" + 				ds_name);
            OdbcDataAdapter da = new OdbcDataAdapter(
            "select percent from cred_rates.txt", cnn);
            cnn.Open();
            DataSet ds = new DataSet();
            da.Fill(ds);
            cnn.Close();
            return ds.Tables[0].Rows[0][0].ToString();
        }
    }

    public bool testOK()
    {
        bool lRes = false;
        OdbcConnection cnn = null;
        try
        {
            cnn = new OdbcConnection(
                    "Driver={Microsoft Text Driver (*.txt; *.csv)};DBQ=" +
            ds_name);
            OdbcDataAdapter da = new OdbcDataAdapter(
            "select percent from cred_rates.txt", cnn);
            cnn.Open();
            DataSet ds = new DataSet();
            da.Fill(ds);
            cnn.Close();
            lRes = true;
        }
        catch
        {
            try
            {
                if (cnn != null && !(cnn.State == ConnectionState.Closed))
                    cnn.Close();
            }
            catch {}
        }
        return lRes;
    }
}
```

В данном случае мы используем уже знакомый нам класс OdbcConnection, а также два новых класса из библиотеки ADO.NET : DataSet (класс, инкапсулирующий набор записей как список таблиц типа DataTable, представляющих собой таблицы с результатами запросов (в общем случае – любые таблицы с определенным интерфейсом, которые могут создаваться множестовм способов), размещаемые в памяти) и OdbcDataAdapter (класс для заполнения заданного DataSet результатом заданного SQL запроса к источнику данных, заданному соединением OdbcConnection). Обратите внимание на то, что с объектом класса DataSet мы можем работать и после закрытия соединения с БД.

Несмотря на очевидные недостатки приведенного кода (к ним мы также вернемся в следующей работе) продолжим рассмотрение набора тестов для него. 

Созданный нами набор тестов для DataSource оставляет желать много лучшего. Во-первых, он мало что тестирует (ему может удовлетворить и тривиальный класс, возвращающий константы по шаблону Подделка). Во-вторых, мы не можем протестировать собственно реагирование класса на изменения в хранимых в БД данных. В-третьих, при изменении хранимых данных тест перестанет срабатывать (и это единственная реакция на изменение, правда, не та, которую хотелось бы получить).

Улучшить ситуацию можно, применив декомпозицию и абстрактные интерфейсы, но об этом – также в последующих работах. Здесь же обратимся к вопросу изоляции тестируемого модуля от реальной БД, к которой он обращается. Добиться этого в некотором смысле мы можем с помощью имени источника данных, которое мы решили задавать в конструкторе. 

Идея состоит в том, что мы должны предложить тестируемому модулю вместо реального физического источника данных наш подставной тестовый источник (по сути это упрощенный вариант использования шаблона Подставной объект). В данном случае это может быть создаваемый на диске каталог и временный текстовый файл со сгенерированным содержимым в виде строк “percent” и, например, “20” (тестируемое значение процента, которое будет считывать тенстируемый объект – источник данных), который будет удаляться после теста.

Тогда тестовый метод может выгладеть так : 
```c#
[Test]
public void testGetData1()
{
    try
    {
        if (!System.IO.Directory.Exists("Data1"))
            System.IO.Directory.CreateDirectory("Data1");
            System.IO.StreamWriter sw = new 				
            System.IO.StreamWriter("Data1\\cred_rates.txt",
            false, Encoding.GetEncoding(1251));
        sw.WriteLine("percent");
        sw.WriteLine("20");
        sw.Close();
    }
    catch { Assert.Fail("Ошибка при создании тестовой таблицы БД"); }

    DataSource ds = new DataSource("Data1");
    Assert.IsTrue(ds.testOK());
    Assert.AreEqual("20", ds.Percent);

    try
    {
        System.IO.File.Delete("Data1\\cred_rates.txt");
    }
    catch { Assert.Fail("Ошибка при удалении тестовой тблицы БД"); }
}
```
Обратите также внимание на использование Assert.Fail() для моделирования сбоя теста при возникновении исключений в тестовом методе.

Данный метод также не является полностью изолированным – он зависит от наличия доступа к файловой системе, от свободного места на диске, кроме того, он тестирует не только сам код модуля DataSource, но и, например, факт наличия или отсутствия в системе ODBC драйвера для текстовых файлов, что тоже можно трактовать как внешний фактор. Но тем не менее, это хотя бы что-то.

Прогоним все тесты модуля источника данных – они проходят (в принципе, второй тестовый метод можно теперь и убрать).  Теперь мы готовы добавить новую функциональность в основную программу, например, так (разместим этот код в новом созданном проекте консольного приложения, зависящего от нашей сборки CalcCredit.dll) :
```c#
	using CalcCredit;

	namespace CalcCredit1stApp
	{
	    class Program
	    {
	        static void Main(string[] args)
	        {
	            Credit c = new Credit(0, 0, 0);

	            string s = "0", s1;

                        
	            while (s.Length > 0) 
	            {
	                Console.Write("Введите сумму кредита : ");
	                s = Console.ReadLine();
	                if (s.Length == 0) continue;

	                c.Sum = Convert.ToDouble(s);

	                DataSource ds = new DataSource("Data");

	                if (ds.testOK())
	                    s = ds.Percent;
	                else
	                    s = "0";

	                Console.Write(
				"Введите процентную ставку кредита (" + s + "%) : ");
	                s1 = Console.ReadLine();
	                s = (s1.Length == 0 ? s : s1);
	                c.Percent = Convert.ToDouble(s);

	                Console.Write("Введите срок кредита в месяцах : ");
	                s = Console.ReadLine();
	                if (s.Length > 0)
	                {
      	              c.Term = Convert.ToInt32(s);
	                }
	                else 
	                {
      	              Console.Write(
				    "Введите желаемую сумму ежемесячных выплат : ");
	                    s = Console.ReadLine();
      	              if (s.Length > 0)
	                    {
      	                  c.DesiredPayment = Convert.ToDouble(s);
	                        Console.WriteLine("Срок кредита (мес.) = " + 
	                            c.Term.ToString());
	                    }
	                    else continue;
	                }
                	    Console.WriteLine("Общая сумма выплат = " + 
	                    c.getTotalPayment().ToString());
      	          Console.WriteLine("Средняя сумма выплат = " + 
            	        c.getAverageMonthPayment().ToString());
	            }
	        }
	    }
	}	
```
Построим по нашим двум проектам диаграмму ObjectiF и соотнесем полученные классы с нашими классами, построенными выше при анализе.

Как видно из диаграммы, по сравнению с результатами первоначального анализа кое-что в результате разработки через тесты изменилось даже в интерфейсе классов (например, два конструктора в классе Credit, параметр в конструкторе DataSource), хотя в целом мы получили просто реализацию запланированных классов, реализующих запланированные прецеденты. С учетом новой функциональности (остутствовавшей в исходном плане) и реализации части второй итерации получаем около 88% решенных поставленных задач из общего числа, или 100% задач по отношению к количеству задач в первоначальном списке (см. далее). Т.о. произошла компенсация части нерешеннных задач дополнительными.
 	 
Скорректированный список задач :
1. Составление плана итерации 
2. Создание проекта и инфраструктуры 
3. Создание эскизного проекта архитектуры 
4. Изучение особенностей средства разработки
5. Изучение оболочки для тестирования
6. Создание приемочного теста
7. Тест создания класса и обращения к методам класса после создания.
8. Тест установки и считывания атрибутов
9. Тест нулевого кредита (полезно проверить краевые значения !)
10. Тест кредита с нулевыми процентами.
11. Тест кредита с процентами, взятого на один месяц
12. Тест кредита с процентами на три месяца
13. Разработка приложения
14. Оценка скорости разработки, планирование (в том числе текущее) 
15. Тест расчета кредита с желаемым среднемесячным платежом.
16. Набор тестов источника данных для считывания процентной ставки из БД.

Реализация : 14 / 16 (~88% ).
По отношению к числу первоначальных задач : 14 / 14 (100%).

## 5. Порядок выполнения работы: 

1.	Познакомиться с оболочкой NUnit. Создать простой проект (из примера в лекции – поиск максимума) для тестирования. Создать проект NUnit. Настроить среду Visual Studio 2017/2019 для вызова проекта NUnit. Запустить наборы тестов из своего и прилагаемого к оболочке примеров.

2.	Создать проект для тех же самых тестов в самой среде VS 2017 / 2019. (Указания : 1) не использовать мастер, создавать тест вручную; 
2) вместо [TestFixture] указать [TestClass()], вместо [Test] – [TestMethod()]).

3.	Разобрать по шагам пример разработки через тестирование для простой задачи с использованием NUnit (вычисление медианного значения ряда) с помощью презентации.
    1.	Открыть исходный проект, проект для тестирования.
    2.	Рассмотреть пошагово пример разработки класса ListStat через тестирование. Для отдельных шагов скомпилировать тестовый проект и прогнать тесты.
    3.	Выполнить рефакторинг условного выражения в классе ListStat.

4.	Разобрать по шагам пример разработки через тестирование приложения для вывода статистики по зарплатам.
    1.	Открыть исходный проект, проект для тестирования.
    2.	Рассмотреть пошагово пример разработки класса ListStat через тестирование. Для отдельных шагов скомпилировать тестовый проект и прогнать тесты.

5.	Изучить другие примеры разработки методов и классов по данному документу.

6.	Разработать для класса ListStat через тесты метод определения средней величины в списке без учета минимального значения, максимального значения или без учета и минимума, и максимума.

7. Использовать TDD при выполнении контрольной работы:
    1.	Разработать подробный план первой итерации до уровня реализуемых тестов.
    2.	Реализовать тесты и модули, необходимые для первой итерации.
Использовать шаблоны тестирования Подделка, Триангуляция, Очевидная реализация и др.
